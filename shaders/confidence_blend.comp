#version 450

/*
 * Confidence-Weighted Blend Shader
 *
 * Blends forward and backward warped frames using cost map confidence.
 * Quality mode: Uses optical flow cost to weight contributions.
 *
 * Low cost = high confidence = trust the motion vector
 * High cost = low confidence = blend more conservatively
 */

layout(local_size_x = 16, local_size_y = 16) in;

// Forward warped frame (prev -> interpolated)
layout(set = 0, binding = 0) uniform sampler2D forwardWarped;

// Backward warped frame (curr -> interpolated)
layout(set = 0, binding = 1) uniform sampler2D backwardWarped;

// Forward cost map
layout(set = 0, binding = 2) uniform sampler2D forwardCost;

// Backward cost map
layout(set = 0, binding = 3) uniform sampler2D backwardCost;

// Output blended frame
layout(set = 0, binding = 4, rgba8) uniform writeonly image2D outputFrame;

// Push constants
layout(push_constant) uniform PushConstants {
    float interpolation;     // 0.0 = prev, 1.0 = curr
    float costScale;         // Scale factor for cost -> confidence
    float minConfidence;     // Minimum confidence threshold
    float _reserved;
} pc;

// Convert cost to confidence (0.0 = low confidence, 1.0 = high confidence)
float costToConfidence(float cost) {
    // Cost is typically 0-255, lower is better
    // Apply sigmoid-like mapping
    float normalized = clamp(cost * pc.costScale, 0.0, 1.0);
    return max(pc.minConfidence, 1.0 - normalized);
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 outputSize = imageSize(outputFrame);

    if (pixelCoord.x >= outputSize.x || pixelCoord.y >= outputSize.y) {
        return;
    }

    vec2 uv = (vec2(pixelCoord) + 0.5) / vec2(outputSize);

    // Sample warped frames
    vec4 fwdColor = texture(forwardWarped, uv);
    vec4 bwdColor = texture(backwardWarped, uv);

    // Sample costs
    float fwdCost = texture(forwardCost, uv).r;
    float bwdCost = texture(backwardCost, uv).r;

    // Convert to confidence
    float fwdConf = costToConfidence(fwdCost);
    float bwdConf = costToConfidence(bwdCost);

    // Temporal weighting based on interpolation factor
    float fwdWeight = (1.0 - pc.interpolation) * fwdConf;
    float bwdWeight = pc.interpolation * bwdConf;

    // Normalize weights
    float totalWeight = fwdWeight + bwdWeight;
    if (totalWeight > 0.001) {
        fwdWeight /= totalWeight;
        bwdWeight /= totalWeight;
    } else {
        // Fallback to simple linear blend
        fwdWeight = 1.0 - pc.interpolation;
        bwdWeight = pc.interpolation;
    }

    // Blend
    vec4 blended = fwdColor * fwdWeight + bwdColor * bwdWeight;

    imageStore(outputFrame, pixelCoord, blended);
}
